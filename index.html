<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Voice Changer with Download</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
  font-family: Arial, sans-serif;
  background: #0a1e44;
  color: #fff;
  text-align: center;
  padding: 30px;
}
button, select, input {
  padding: 10px;
  margin: 10px;
  font-size: 16px;
}
</style>
</head>
<body>

<h1>Voice Changer</h1>

<input type="file" accept="audio/*" onchange="loadFile(event)">
<br>

<select id="effect">
  <option value="normal">Normal</option>
  <option value="male">Male Voice</option>
  <option value="female">Female Voice</option>
  <option value="echo">Echo</option>
</select>

<br>

<button onclick="processAndDownload()">Process & Download</button>

<script>
let audioBuffer;

async function loadFile(e) {
  const file = e.target.files[0];
  const ctx = new AudioContext();
  const arrayBuffer = await file.arrayBuffer();
  audioBuffer = await ctx.decodeAudioData(arrayBuffer);
}

async function processAndDownload() {
  if (!audioBuffer) {
    alert("Upload an audio file first.");
    return;
  }

  const effect = document.getElementById("effect").value;

  const offlineCtx = new OfflineAudioContext(
    audioBuffer.numberOfChannels,
    audioBuffer.length,
    audioBuffer.sampleRate
  );

  const source = offlineCtx.createBufferSource();
  source.buffer = audioBuffer;

  let lastNode = source;

  if (effect === "male") {
    source.playbackRate.value = 0.8;
  }

  if (effect === "female") {
    source.playbackRate.value = 1.3;
  }

  if (effect === "echo") {
    const delay = offlineCtx.createDelay();
    delay.delayTime.value = 0.25;
    lastNode.connect(delay);
    lastNode = delay;
  }

  lastNode.connect(offlineCtx.destination);
  source.start(0);

  const renderedBuffer = await offlineCtx.startRendering();
  downloadWav(renderedBuffer);
}

function downloadWav(buffer) {
  const wav = audioBufferToWav(buffer);
  const blob = new Blob([wav], { type: "audio/wav" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "edited_audio.wav";
  a.click();

  URL.revokeObjectURL(url);
}

function audioBufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels;
  const length = buffer.length * numChannels * 2 + 44;
  const bufferArray = new ArrayBuffer(length);
  const view = new DataView(bufferArray);

  let offset = 0;
  function writeString(s) {
    for (let i = 0; i < s.length; i++) {
      view.setUint8(offset++, s.charCodeAt(i));
    }
  }

  writeString("RIFF");
  view.setUint32(offset, length - 8, true); offset += 4;
  writeString("WAVE");
  writeString("fmt ");
  view.setUint32(offset, 16, true); offset += 4;
  view.setUint16(offset, 1, true); offset += 2;
  view.setUint16(offset, numChannels, true); offset += 2;
  view.setUint32(offset, buffer.sampleRate, true); offset += 4;
  view.setUint32(offset, buffer.sampleRate * numChannels * 2, true); offset += 4;
  view.setUint16(offset, numChannels * 2, true); offset += 2;
  view.setUint16(offset, 16, true); offset += 2;
  writeString("data");
  view.setUint32(offset, buffer.length * numChannels * 2, true); offset += 4;

  for (let i = 0; i < buffer.length; i++) {
    for (let ch = 0; ch < numChannels; ch++) {
      let sample = buffer.getChannelData(ch)[i];
      sample = Math.max(-1, Math.min(1, sample));
      view.setInt16(offset, sample * 0x7fff, true);
      offset += 2;
    }
  }

  return bufferArray;
}
</script>

</body>
</html>
